---
title: 《深入理解Java虚拟机》阅读笔记
toc: true
date: 2017-06-11 20:44:24
tags:
- JVM
---
# 第1章 走近Java
世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。
### 1.2 Java技术体系
Sun官方所定义的Java技术体系：

	Java程序设计语言
	各种硬件平台上的Java虚拟机
	Class文件格式
	Java API类库
	来自商业机构和开源社区的第三方Java类库

JDK：Java程序设计语言，Java虚拟机，Java API类库
JDK是支持Java程序开发的最小环境

JRE：Java API类库中的Java SE API子集，Java虚拟机
JRE是支持Java程序运行的标准环境
### 1.3 Java发展史
1991年4月，由James Gosling博士领导的绿色计划创造了Oak(橡树)。
1995年5月23日，Oak语言改名为Java。
1996年1月23日，JDK1.0发布，提供了一个纯解释执行的Java虚拟机(Sun Classic VM)。
1998年12月4日，JDK1.2发布。
1999年4月27日，HotSpot虚拟机发布，成为1.3之后Sun JDK的默认虚拟机。
2000年5月8日，JDK1.3发布。
2002年2月13日，JDK1.4发布。
2004年9月30日，JDK1.5发布。
2006年12月11日，JDK1.6发布。
2006年11月13日，JavaOne大会上Sun公司宣布Java开源。
2009年2月19日，JDK1.7发布。
2009年4月20日，Oracle公司收购Sun公司。
2013年9月，JDK1.8发布。
### 1.4 Java虚拟机发展史
# 第2章 Java内存区域与内存溢出异常
Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。
### 2.2运行时数据区域
#### 2.2.1程序计数器
程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。
每条线程都有一个独立的程序计数器，所以程序计数器为线程私有的内存。
#### 2.2.2Java虚拟机栈
与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。
每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
#### 2.2.3本地方法栈
本地方法栈和虚拟机栈相似，虚拟机栈为虚拟机执行java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。
#### 2.2.4Java堆
Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。
此内存区域的唯一目的就是存放对象实例。
Java堆是垃圾收集器管理的主要区域。
#### 2.2.5方法区
方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编辑器编译后的代码等数据。
#### 2.2.6运行时常量池
运行时常量池是方法区的一部分。
Class文件中有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
运行时常量池相对于Class文件常量池的重要特征是具备动态性。
#### 2.2.7直接内存
直接内存并不是虚拟机运行时数据区的一部分。
JDK1.4中加入了NIO，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用来进行操作。
### 2.3HotSpot虚拟机对象探秘
#### 2.3.1对象的创建
虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析、和初始化过。如果没有，那必须先执行相应的类加载过程。
在类加载通过后，接下来虚拟机将为新生对象分配内存。分配内存有“指针碰撞”和“空闲列表”2种方式，取决于GC是否带有压缩整理功能。内存分配的2种同步方法，一种是对分配内存空间的动作进行同步处理————实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲。
内存分配完成后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头中。
在上面工作完成后，从虚拟机的角度看就，一个新的对象已经诞生了，但从Java程序来看，对象创建才刚刚开始————<init>方法还没有执行，所有字段都为0.当<init>方法执行后，一个真正可用的对象才算产生出来。
#### 2.3.2对象的内存布局
在HotSpot虚拟机中，对象在内存中存储的布局分为3个区域：对象头、实例数据和对齐填充。
对象头包括2部分，第一部分用于存储对象自身的运行时数据，官方称它为“Mark Word”，另一部分是类型指针。
实例数据是对象真正存储的有效信息。
对齐填充没有特别的含义，仅仅起着占位符的作用。
#### 2.3.3对象的访问定位
Java程序需要通过栈上的reference数据来操作堆上的具体对象。
目前主流的访问方式有句柄和直接指针。2种方式的图示这里就省略了。
# 第3章 垃圾收集器与内存分配策略
### 3.2对象已死吗
#### 3.2.1引用计数算法
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的。
缺点是无法解决对象之间相互循环引用的问题。
#### 3.2.2可达性分析算法
通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
Java语言中可以作为GC Roots的对象有4种，这里也省略。
#### 3.2.3再谈引用
JDK1.2后，将引用分为强引用，软引用，弱引用，虚引用。4种引用概念这里省略。
#### 3.2.4生存还是死亡
要宣告一个对象的死亡，至少要经历两次标记过程。
如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这2种情况都视为“没有必要执行”。
如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记。
#### 3.2.5回收方法区
永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。
### 3.3垃圾收集算法
#### 3.3.1标记-清除算法
#### 3.3.2复制算法
#### 3.3.3标记-整理算法
#### 3.3.4分代收集算法




# 第4章 虚拟机性能监控与故障处理工具
# 第5章	调优案例分析与实战
# 第6章 类文件结构
代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。
### 6.3Class类文件的结构
Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。
无符号数属于基本的数据类型。
表是由多个无符号数或者其他表作为数据项构成的复合数据类型。
#### 6.3.1魔数与Class文件的版本
每个Class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。
紧接着魔数的4个字节存储的是Class文件的版本号：第5,6个字节是次版本号，第7,8个字节是主版本号。
#### 6.3.2常量池


# 第7章 虚拟机类加载机制
# 第8章	虚拟机字节码执行引擎
# 第9章	类加载及执行子系统的案例与实战
# 第10章 早期(编译期)优化
从计算机程序出现的第一天起，对效率的追求就是程序天生的坚定信仰，这个过程犹如一场没有终点、永不停歇的F1方程式竞赛，程序员是车手，技术平台则是在赛道上飞驰的赛车。
# 第11章	 晚期(运行期)优化
# 第12章 Java内存模型与线程
并发处理的广泛应用是使得Amdahl定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。
# 第13章 线程安全与锁优化